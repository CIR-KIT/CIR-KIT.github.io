<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ubuntu | 九州工業大学 CIR-KIT Blog]]></title>
  <link href="http://cir-kit.github.io/blog/categories/ubuntu/atom.xml" rel="self"/>
  <link href="http://cir-kit.github.io/"/>
  <updated>2015-03-15T03:10:29+09:00</updated>
  <id>http://cir-kit.github.io/</id>
  <author>
    <name><![CDATA[CIR-KIT Members]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[No.7-1:プラグインを書く (Gazebo Plugin 101 編)]]></title>
    <link href="http://cir-kit.github.io/blog/2015/03/11/gazebo-plugin-101/"/>
    <updated>2015-03-11T10:42:29+09:00</updated>
    <id>http://cir-kit.github.io/blog/2015/03/11/gazebo-plugin-101</id>
    <content type="html"><![CDATA[<p><img src="/images/gazebo_logo.png" alt="gazebo_logo" /></p>

<h5>検証日時</h5>

<p>03/04/2015 (Wed)</p>

<h5>概要</h5>

<p>Gazeboのチュートリアル第七弾「Write a plugin」。
プラグインを使えば、モデルやセンサ、worldプロパティをコントロールしたり、Gazeboを起動させたりできます。様々な目的のために、どのようにしてプラグインを作成したり、ロードしたりしたらよいかを述べてゆきます。
今回はその「Gazebo plugin 101」編です。
公式サイトを適当に翻訳しただけですので、あしからず。</p>

<h5>レベル</h5>

<p><strong>INTERMEDIATE</strong></p>

<!-- more -->


<h5>環境</h5>

<table>
<thead>
<tr>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>PC</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Lenovo ThinkPad X240 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Prosessor</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Intel Core i7-4600U (2.10GHz, 4MB, 1600MHz) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>RAM</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> PC3-12800 DDR3L (8GB) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>OS</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Ubuntu 14.04 LTS 64bit </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Kernel</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> 3.13.0-44-generic </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Gazebo</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Version 5.0.1 </td>
</tr>
</tbody>
</table>


<h5>参考</h5>

<p><a href="http://gazebosim.org/tutorials?cat=write_plugin">GAZEBO Tutorial-Write a Plugin</a></p>

<h2>Gazeboプラグインの概要</h2>

<p>プラグインとは、共有ライブラリとしてコンパイルされ、シミュレーションに取り込まれるコードの集合です。標準C++クラスを通じて、プラグインはすべてのGazeboの機能に直接アクセスします。<br/>
プラグインは有用です。なぜなら、:</p>

<ul>
<li>Gazeboのほとんどすべてのアスペクトを開発者がコントロールできる。</li>
<li>簡単に共有できる独立したルーチンがある。</li>
<li>実行中のシステムに挿入したり、削除したりできる。</li>
</ul>


<p>Gazeboの最新バージョンはコントローラとして使われています。これは、プラグインと同じような特徴を持ちますが、Gazeboのなかで、静的にコンパイルされています。プラグインはより柔軟に、かつシミュレーションに含まれる機能を選べるようにします。<br/>
以下の様なとき、プラグインを使うべきです。:</p>

<ul>
<li>シミュレーションをプログラマチックに変更したいとき

<ul>
<li>モデルを動かす、イベントの反応をかえす、前提条件を持った新しいモデルを挿入するとき

<ul>
<li>トランスポートレイヤのオーバーヘッド無しに、Gazeboに高速なインターフェースがほしいとき</li>
</ul>
</li>
<li>メッセージのシリアル化と非シリアル化

<ul>
<li>他に利益をもたらすコードがあり、それを共有したいとき</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>プラグインの種類</h2>

<p>現在、以下のようにプラグインは5種類あります。</p>

<ol>
<li>World</li>
<li>Model</li>
<li>Sensor</li>
<li>System.</li>
<li>Visual.</li>
</ol>


<p>それぞれのプラグインタイプは異なるGazeboのコンポーネントで管理されています。例えば、ModelプラグインがGazeboのある特定のモデルのコントローラに接続されているなどが挙げられます。同じように、Worldプラグインはworldに接続され、Sensorプラグインはsensorに接続されます。システムプラグインはコマンドラインで定義され、Gazeboの初回起動時にロードします。このプラグインは初回起動時にユーザーコントロールを与えます。<br/>
プラグインの種類は望みの機能に沿ったものでなければなりません。Worldプラグインは物理エンジンや証明の設定などのworldプロパティをコントロールするのに使って下さい。Modelプラグインは、ジョイントやモデルの姿勢をコントロールするために使用して下さい。センサプラグインはセンサ情報を定義し、センサプロパティをコントロールするために使用して下さい。</p>

<h2>Hello World プラグイン</h2>

<p>プラグインはシンプルに設計されています。ベアボーンのworldプラグインにはいくつかの関数と共にクラスが含まれています。<br/>
最初に、デビアンパッケージよりGazeboをインストールしたら、Gazeboの開発用ファイルをインストールするのを忘れないで下さい。もし、あなたがGazeboをソースコードからインストールしたなら、このステップは無視して構いません。もし<code>gazebo5</code>よりも古いリリースのGazeboを使用しているなら、<code>5</code>の部分を持っているバージョンの番号に置き換えて以下の内容をご覧ください。</p>

<pre><code class="bash">sudo apt-get install libgazebo5-dev
</code></pre>

<p>続いて、ディレクトリを作り、新しい<code>.cc</code>ファイルのプラグインを作成して下さい。</p>

<pre><code class="bash"> mkdir ~/gazebo_plugin_tutorial
 cd ~/gazebo_plugin_tutorial
 gedit hello_world.cc
</code></pre>

<p>できたら、以下を<code>hello_world.cc</code>にコピーして下さい。</p>

<pre><code class="cpp">#include &lt;gazebo/gazebo.hh&gt;

namespace gazebo
{
  class WorldPluginTutorial : public WorldPlugin
  {
    public: WorldPluginTutorial() : WorldPlugin()
            {
              printf("Hello World!\n");
            }

    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
            {
            }
  };
  GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
}
</code></pre>

<p>上記のコードはGazeboのソースコード : <a href="https://bitbucket.org/osrf/gazebo/src/gazebo_2.2/examples/plugins/hello_world/">examples/plugins/helloworld/helloworld</a>にもあります。尚、リンク先には<code>CMakeLists.txt</code>ファイルもあります。</p>

<h3>コードの説明</h3>

<pre><code class="cpp">#include &lt;gazebo/gazebo.hh&gt;

namespace gazebo
{
</code></pre>

<p><a href="https://bitbucket.org/osrf/gazebo/src/gazebo_2.2/gazebo/gazebo_core.hh">gazebo/gazebo.hh</a>ファイルは基本的なGazeboの関数群のコアをインクルードしています。これは、<code>gazebo/physics/physics.hh</code>や<code>gazebo/rendering/rendering.hh</code>、<code>gazebo/sensors/sensors.hh</code>を臨機応変でインクルードされるべきものとしてインクルードしていません。すべてのプラグインは<code>gazebo</code>という名前空間が必要です。</p>

<pre><code class="cpp">  class WorldPluginTutorial : public WorldPlugin
  {
    public: WorldPluginTutorial() : WorldPlugin()
            {
              printf("Hello World!\n");
            }
</code></pre>

<p>それぞれのプラグインはプラグインタイプを継承しなければなりません。今回の例では、<code>WorldPlugin</code>クラスを継承します。</p>

<pre><code class="cpp">    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
            {
            }
</code></pre>

<p>その他の必須の関数は<code>Load</code>です。これはロードされるSDFファイルによって定義される属性や要素を含むSDF要素を受け取ります。</p>

<pre><code class="cpp">  GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
</code></pre>

<p>最終的に、プラグインは<code>GZ_REGISTER_WORLD_PLUGIN</code>マクロを使ってシミュレーションと共に登録されなければなりません。このマクロへの唯一のパラメータはプラグインクラスの名前です。それぞれのプラグインタイプに合わせて登録されたマクロの照合が行われます。: <code>GZ_REGISTER_MODEL_PLUGIN</code>, <code>GZ_REGISTER_SENSOR_PLUGIN</code>, <code>GZ_REGISTER_SYSTEM_PLUGIN</code>、<code>GZ_REGISTER_VISUAL_PLUGIN</code>などです。<br/>
以下のセクションではこのプラグインをどのようにしてコンパイルするかについての簡単な説明も行ってゆきます。</p>

<h3>プラグインをコンパイルする</h3>

<p>Gazeboが正しくインストールされていることを確認して下さい。<br/>
上記のプラグインをコンパイルするために、<code>~/gazebo_plugin_tutorial/CMakeLists</code>を作成して下さい。:</p>

<pre><code class="bash"> gedit ~/gazebo_plugin_tutorial/CMakeLists.txt
</code></pre>

<p>以下を<code>CMakeLists.txt</code>にコピーして下さい。:</p>

<pre><code class="cmake">cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

find_package(Boost REQUIRED COMPONENTS system)
include_directories(${Boost_INCLUDE_DIRS})
link_directories(${Boost_LIBRARY_DIRS})

include (FindPkgConfig)
if (PKG_CONFIG_FOUND)
  pkg_check_modules(GAZEBO gazebo)
endif()
include_directories(${GAZEBO_INCLUDE_DIRS})
link_directories(${GAZEBO_LIBRARY_DIRS})

add_library(hello_world SHARED hello_world.cc)
target_link_libraries(hello_world ${GAZEBO_LIBRARIES} ${Boost_LIBRARIES})
</code></pre>

<p>ビルドディレクトリを作成して下さい。</p>

<pre><code class="bash"> mkdir ~/gazebo_plugin_tutorial/build
 cd ~/gazebo_plugin_tutorial/build
</code></pre>

<p>コードをコンパイルして下さい。</p>

<pre><code class="bash"> cmake ../
 make
</code></pre>

<p>コンパイルの結果は共有ライブラリにでき、<code>~/gazebo_plugin_tutorial/build/libhello_world.so</code>をGazeboシミュレーションに挿入することができます。<br/>
最後に、ライブラリパスを<code>GAZEBO_PLUGIN_PATH</code>に追加して下さい。:</p>

<pre><code class="bash"> export GAZEBO_PLUGIN_PATH={GAZEBO_PLUGIN_PATH}:~/gazebo_plugin_tutorial/build
</code></pre>

<h2>プラグインを使う</h2>

<p>プラグインを共有ライブラリとしてコンパイルしたら(上記をご覧ください)、SDFファイルのworldやmodelにそれを追加することができます(詳しくは、<a href="http://gazebosim.org/sdf.html">SDFドキュメント</a>をご覧ください)。最初に、GazeboはSDFファイルを解析し、プラグインを設置します。そしてコードを読み込みます。Gazeboがプラグインを探すことができるというのはとても重要なことです。プラグインへの絶対パスが定義されている、もしくはプラグインが<code>GAZEBOPLUGINPATH</code>パスの中にあればプラグインを利用した環境が利用可能です。<br/>
worldファイルの例は、<a href="https://bitbucket.org/osrf/gazebo/src/gazebo_2.2/examples/plugins/hello_world/hello.world">examples/plugins/helloworld/helloworld</a>でも見つけることができます。</p>

<pre><code class="xml">&lt;?xml version="1.0"?&gt;
&lt;sdf version="1.4"&gt;
  &lt;world name="default"&gt;
    &lt;plugin name="hello_world" filename="libhello_world.so"/&gt;
  &lt;/world&gt;
&lt;/sdf&gt;
</code></pre>

<p><code>~/gazebo_plugin_tutorial/hello.world</code>にあるファイルのコピーを作成して下さい。<br/>
もし、<code>GAZEBO_PLUGIN_PATH</code>の中にビルドディレクトリがないなら、Gazeboサーバーをビルドディレクトリから起動しなければなりません。</p>

<pre><code class="bash">$ cd build
$ gzserver ../hello.world --verbose
</code></pre>

<p>うまく実行できれば、以下のような出力を得られるはずです。:</p>

<pre><code class="bash">Gazebo multi-robot simulator, version 1.9.5
Copyright (C) 2013 Open Source Robotics Foundation.
Released under the Apache 2 License.
http://gazebosim.org

Msg Waiting for master
Msg Connected to gazebo master @ http://localhost:11345
Hello World!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[No.6-10:GazeboをROSに繋ぐ (発展的なROSの統合 編)]]></title>
    <link href="http://cir-kit.github.io/blog/2015/03/04/gazebo-ros-advanced-integration/"/>
    <updated>2015-03-04T05:26:59+09:00</updated>
    <id>http://cir-kit.github.io/blog/2015/03/04/gazebo-ros-advanced-integration</id>
    <content type="html"><![CDATA[<p><img src="/images/gazebo_logo.png" alt="gazebo_logo" /></p>

<h5>検証日時</h5>

<p>03/04/2015 (Wed)</p>

<h5>概要</h5>

<p>Gazeboのチュートリアル第六弾「Connect to ROS」。
ROSはロボットの制御フレームワークです。このチュートリアルでは、GazeboとROSのインターフェースについて説明します。
今回はその「Advanced ROS Integratio」編です。
公式サイトを適当に翻訳しただけですので、あしからず。</p>

<h5>レベル</h5>

<p><strong>INTERMEDIATE</strong></p>

<!-- more -->


<h5>環境</h5>

<table>
<thead>
<tr>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>PC</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Lenovo ThinkPad X240 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Prosessor</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Intel Core i7-4600U (2.10GHz, 4MB, 1600MHz) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>RAM</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> PC3-12800 DDR3L (8GB) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>OS</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Ubuntu 14.04 LTS 64bit </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Kernel</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> 3.13.0-44-generic </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Gazebo</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Version 5.0.1 </td>
</tr>
</tbody>
</table>


<h5>参考</h5>

<p><a href="http://gazebosim.org/tutorials?cat=connect_ros">GAZEBO Tutorial-Connect to ROS</a></p>

<h2>チュートリアル : 発展的なROSの統合</h2>

<h3>動的再構成</h3>

<p>物理エンジンのパラメータの一部は<a href="http://cir-kit.github.io/blog/2015/02/03/gazebo-modifying-a-world/">環境を修正する</a>のチュートリアルで行ったように、Gazeboに合わせることが出きます。これに加えて、ROSの動的再構成メカニズムを使うことで、これらのパラメータを調整できます。<br/>
例として、シミュレーション中の重力を入れ替えてみます。以下のインストールが完了しているか確認してください。:</p>

<h5>Groovyの場合</h5>

<pre><code class="bash">sudo apt-get install ros-groovy-rqt-common-plugins ros-groovy-dynamic-reconfigure
</code></pre>

<h5>Hydroの場合</h5>

<pre><code class="bash">sudo apt-get install ros-hydro-rqt-common-plugins ros-hydro-dynamic-reconfigure
</code></pre>

<h5>Indigoの場合</h5>

<pre><code class="bash">sudo apt-get install ros-indigo-rqt-common-plugins ros-indigo-dynamic-reconfigure
</code></pre>

<p>続いて、Gazeboを起動してください。:</p>

<pre><code class="bash">rosrun gazebo_ros gazebo
</code></pre>

<p>物理エンジンについての変更を行う前に、Gazeboのモデルを挿入しましょう。画面左のタブより<strong>Insert</strong>をkリックし、<strong>Pioneer 2DX</strong>のロボットモデルをクリックしてください。<br/>
完了したら、ランタイムのGazeboと情報を交換するために、ROSのGUIツールを起動してください。</p>

<pre><code class="bash">rosrun rqt_gui rqt_gui
</code></pre>

<p><img src="/images/2015-03-04-ros-advanced-integration/rqt.png" alt="rqt" /></p>

<p>上に載せたキャプチャと一致するように、RQT(前述のROSのGUI)のパラメータを設定してください。<br/>
RQTの左側にある<strong>gazebo</strong>をクリックすると、調整可能な物理エンジンのパラメータのリストを確認できます。<br/>
確認できたら、<code>gravity_z</code>を<strong>-9.8</strong>から<strong>+9.8</strong>にして、あなたのロボットに重力がどのような影響を及ぼすか、確認してみてください。<br/>
ちなみに、変更すると、<strong>Pioneer2DX</strong>がどっかに飛んでいったはずです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[No.6-9:GazeboをROSに繋ぐ (ROS Plugin 編)]]></title>
    <link href="http://cir-kit.github.io/blog/2015/03/04/gazebo-ros-plugin/"/>
    <updated>2015-03-04T04:45:47+09:00</updated>
    <id>http://cir-kit.github.io/blog/2015/03/04/gazebo-ros-plugin</id>
    <content type="html"><![CDATA[<p><img src="/images/gazebo_logo.png" alt="gazebo_logo" /></p>

<h5>検証日時</h5>

<p>03/04/2015 (Wed)</p>

<h5>概要</h5>

<p>Gazeboのチュートリアル第六弾「Connect to ROS」。
ROSはロボットの制御フレームワークです。このチュートリアルでは、GazeboとROSのインターフェースについて説明します。
今回はその「ROS Plugin」編です。
公式サイトを適当に翻訳しただけですので、あしからず。</p>

<h5>レベル</h5>

<p><strong>INTERMEDIATE</strong></p>

<!-- more -->


<h5>環境</h5>

<table>
<thead>
<tr>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>PC</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Lenovo ThinkPad X240 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Prosessor</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Intel Core i7-4600U (2.10GHz, 4MB, 1600MHz) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>RAM</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> PC3-12800 DDR3L (8GB) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>OS</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Ubuntu 14.04 LTS 64bit </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Kernel</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> 3.13.0-44-generic </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Gazebo</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Version 5.0.1 </td>
</tr>
</tbody>
</table>


<h5>参考</h5>

<p><a href="http://gazebosim.org/tutorials?cat=connect_ros">GAZEBO Tutorial-Connect to ROS</a></p>

<h2>チュートリアル : ROSプラグイン</h2>

<p>このチュートリアルでは、とても基本的なROSに関するGazeboのプラグインを作ってゆきます。</p>

<h2>ROSパッケージを作る</h2>

<p>あなたの<code>catkin</code>ワークスペースに新しいROSパッケージを作成してください。:</p>

<pre><code class="bash">cd ~/catkin_ws
catkin_create-pkg gazebo_tutorials gazebo_ros roscpp
</code></pre>

<h2>プラグインを作る</h2>

<p><a href="http://gazebosim.org/tutorials?tut=plugins_hello_world&amp;cat=write_plugin">ここ</a>で説明したような簡単なプラグインを制作し、<code>gazebotutorials/src/simpleworld_plugin.cpp</code>として保存してください。:</p>

<pre><code class="cpp">#include &lt;gazebo/common/Plugin.hh&gt;
#include &lt;ros/ros.h&gt;

namespace gazebo
{
class WorldPluginTutorial : public WorldPlugin
{
public:
  WorldPluginTutorial() : WorldPlugin()
  {
  }

  void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
  {
    // Make sure the ROS node for Gazebo has already been initialized                                                                                    
    if (!ros::isInitialized())
    {
      ROS_FATAL_STREAM("A ROS node for Gazebo has not been initialized, unable to load plugin. "
        &lt;&lt; "Load the Gazebo system plugin 'libgazebo_ros_api_plugin.so' in the gazebo_ros package)");
      return;
    }

    ROS_INFO("Hello World!");
  }

};
GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)
}
</code></pre>

<h2><code>CMakeLists.txt</code>をアップデートする</h2>

<p><code>gazebo_tutorials/CMakeLists.txt</code>を開き、以下のようにしてください。:</p>

<pre><code class="cmake">cmake_minimum_required(VERSION 2.8.3)
project(gazebo_tutorials)

# Load catkin and all dependencies required for this package
find_package(catkin REQUIRED COMPONENTS 
  roscpp 
  gazebo_ros 
)

# Depend on system install of Gazebo
find_package(gazebo REQUIRED)

link_directories(${GAZEBO_LIBRARY_DIRS})
include_directories(${Boost_INCLUDE_DIR} ${catkin_INCLUDE_DIRS} ${GAZEBO_INCLUDE_DIRS})

add_library(${PROJECT_NAME} src/simple_world_plugin.cpp)
target_link_libraries(${PROJECT_NAME} ${catkin_LIBRARIES} ${GAZEBO_LIBRARIES})

catkin_package(
  DEPENDS 
    roscpp 
    gazebo_ros 
)
</code></pre>

<h2><code>package.xml</code>をアップデートする</h2>

<p>以下の行をタグの中に追加し(タグがなければ、タグも追加)、<code>gazebo_tutorials/package.xml</code>をアップデートしてください。</p>

<pre><code class="xml">  &lt;gazebo_ros plugin_path="${prefix}/lib" gazebo_media_path="${prefix}" /&gt;
</code></pre>

<h2>プラグインをコンパイルする</h2>

<p>catkinをあなたのワークスペースで実行して、プラグインをビルドしてください。</p>

<pre><code class="bash">cd ~/catkin_ws
catkin_make
</code></pre>

<h2>Worldファイルを作る</h2>

<p>以下のファイルを<code>gazebo_tutorials/worlds/hello.World</code>として保存してください。:</p>

<pre><code class="xml">&lt;?xml version="1.0" ?&gt;
&lt;sdf version="1.4"&gt;
  &lt;world name="default"&gt;
    &lt;include&gt;
      &lt;uri&gt;model://ground_plane&lt;/uri&gt;
    &lt;/include&gt;

    &lt;include&gt;
      &lt;uri&gt;model://sun&lt;/uri&gt;
    &lt;/include&gt;

    &lt;!-- reference to your plugin --&gt;
    &lt;plugin name="gazebo_tutorials" filename="libgazebo_tutorials.so"/&gt;
  &lt;/world&gt;
&lt;/sdf&gt;
</code></pre>

<h2>Launchファイルを作る</h2>

<p>以下のファイルを<code>gazebo_tutorials/launch/hello.launch</code>として作成してください。:</p>

<pre><code class="xml">&lt;launch&gt;
  &lt;!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched --&gt;
  &lt;include file="$(find gazebo_ros)/launch/empty_world.launch"&gt;
    &lt;arg name="world_name" value="$(find gazebo_tutorials)/worlds/hello.world"/&gt;
    &lt;!-- more default parameters can be changed here --&gt;
  &lt;/include&gt;
&lt;/launch&gt;
</code></pre>

<h2>プラグインを実行する</h2>

<pre><code class="bash">roslaunch gazebo_tutorials hello.launch
</code></pre>

<p>空のGazeboが開き、ターミナルには以下のような文字列が表示されるはずです。:</p>

<pre><code class="bash"> INFO ros.gazebo_tutorials: Hello World!
</code></pre>

<h2>テンプレートから始める</h2>

<p>GazeboとROSのプラグインについて手っ取り早く理解するには、テンプレートが有効です。:</p>

<p><a href="https://github.com/ros-simulation/gazebo_ros_pkgs/blob/hydro-devel/gazebo_plugins/src/gazebo_ros_template.cpp">gazeborostemplate.cpp</a></p>

<h2>機能性を追加する</h2>

<p>GazeboとROSで有用な効果を果たすプラグインを作るために、<a href="http://gazebosim.org/tutorials/?cat=write_plugin">プラグインについて</a>のチュートリアルを読むことをおすすめします。</p>

<h2>ROSのノードの注意点</h2>

<p>もし、ROSノードが<code>Load()</code>関数によって初期化されているなら、すべての<code>gazebo-ros</code>プラグインは、チェックするべきです。これについては、<a href="http://answers.gazebosim.org/question/1493/rosinit-needed-for-ros-gazebo-plugin/">issues</a>でも議論されています。ROSノードの初期化は、実行した時に自動的に初期化されます。</p>

<pre><code class="bash">rosrun gazeboros gazebo
</code></pre>

<p>もしくは、<code>empty.world</code>のlaunchファイルを使用してください。<br/>
<code>gazeboros/src/gazeborosapi_plugin.cpp</code>は<code>ros::init()</code>をコールするGazeboの中にのみあるべきです。</p>

<h2>次のステップ</h2>

<p>様々な、Gazebo-ROS間の仕組みについては、<a href="http://cir-kit.github.io/blog/2015/03/04/gazebo-ros-advanced-integration/">発展的なROSの統合</a>をご覧ください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[No.6-8:GazeboをROSに繋ぐ (ROS Communication 編)]]></title>
    <link href="http://cir-kit.github.io/blog/2015/03/02/gazebo-ros-communication/"/>
    <updated>2015-03-02T21:11:56+09:00</updated>
    <id>http://cir-kit.github.io/blog/2015/03/02/gazebo-ros-communication</id>
    <content type="html"><![CDATA[<p><img src="/images/gazebo_logo.png" alt="gazebo_logo" /></p>

<h5>検証日時</h5>

<p>03/02/2015 (Mon)</p>

<h5>概要</h5>

<p>Gazeboのチュートリアル第六弾「Connect to ROS」。
ROSはロボットの制御フレームワークです。このチュートリアルでは、GazeboとROSのインターフェースについて説明します。
今回はその「ROS Communication」編です。
公式サイトを適当に翻訳しただけですので、あしからず。</p>

<h5>レベル</h5>

<p><strong>INTERMEDIATE</strong></p>

<!-- more -->


<h5>環境</h5>

<table>
<thead>
<tr>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
<th style="text-align:center;"> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>PC</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Lenovo ThinkPad X240 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Prosessor</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Intel Core i7-4600U (2.10GHz, 4MB, 1600MHz) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>RAM</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> PC3-12800 DDR3L (8GB) </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>OS</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Ubuntu 14.04 LTS 64bit </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Kernel</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> 3.13.0-44-generic </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Gazebo</strong> </td>
<td style="text-align:center;"> <strong> : </strong> </td>
<td style="text-align:center;"> Version 5.0.1 </td>
</tr>
</tbody>
</table>


<h5>参考</h5>

<p><a href="http://gazebosim.org/tutorials?cat=connect_ros">GAZEBO Tutorial-Connect to ROS</a></p>

<h2>チュートリアル : ROS Communication</h2>

<p>Gazeboはユーザにシミュレートされたworldの様々な角度を取得したり修正したりできるROSのAPIを提供しています。以下のセクションでは、シミュレーションのworldと物体を操るための効果について説明します。GazeboのためのROSメッセージとサービスの完全なリストはこのチュートリアルに書いてあります。</p>

<h2>必要条件</h2>

<p>これから説明する例を実行していきたいなら、RRBotのセットアップは、<a href="http://cir-kit.github.io/blog/2015/02/17/gazebo-urdf-in-gazebo/">GazeboにおけるURDF</a>のチュートリアルで述べているということを念頭に置いてください。このチュートリアルでは、いろいろな方法を使ってコーラの缶を<strong>蹴ります</strong>。<br/>
また、Gazeboが以下のコマンドですでにlaunchされていると仮定して話を進めます。:</p>

<pre><code class="bash">roscore &amp;
rosrun gazebo_ros gazebo
</code></pre>

<p>ただし、これから紹介するコマンドを打った後に、Gazeboを再起動する必要があるかもしれません。</p>

<h2><code>gazeborosapi_plugin</code>について</h2>

<p><code>gazeboros</code>パッケージと共に配置されている<code>gazeborosapi_plugin</code>は、<code>gazebo</code>と呼ばれるROSのノードを初期化します。これは、これから説明する様なROSのインターフェースを供給するために、ROSコールバックスケジュラー(<code>message passing</code>)とGazeboのインターナショナルスケジュラーを統合しています。このROSのAPIはユーザーがROSを超えたシミュレーション環境の詳細を扱うのと同じように、環境のモデルの姿勢の内観とスポーンを行うことを可能にします。<br/>
また、このプラグインは<code>gzserver</code>によってのみ読み込まれます。</p>

<h2><code>gazeborospaths_plugin</code>について</h2>

<p>２つ目の<code>gazeborospath_plugin</code>という名前のプラグインはGazeboがROSリソースを探す(例えば、ROSパッケージのパス名を解決する)ことを可能にする<code>gazebo ros</code>パッケージの中で利用可能です。<br/>
このプラグインは<code>gzserver</code>と<code>gzclient</code>の両方によって読み込まれます。</p>

<h2>Gazeboのpublishしたパラメータ</h2>

<p>Parameters</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> /usesimtime </td>
<td style="text-align:center;"> Bool </td>
<td style="text-align:center;"> ROSがpublishされたROS timeのための<code>/clock</code>トピックを使うかどうか定義します </td>
</tr>
</tbody>
</table>


<p>Gazeboは、もしシミュレーション時間が<code>/usertime</code>パラメータに使用されるべきなら、他のアプリケーション(とりわけRviz)を定義するためにROSパラメータサーバーを使用します。これは、あなたが<code>gazebo_ros</code>を起動した時に、Gazeboが自動で設定すべきことです。<br/>
もし、ROSシステムをシミュレーション同期時間と共に提供するために、<code>gazebo_ros</code>がROSの<code>/clock</code>トピックをpublishしているなら、<code>usesimtime</code>は<code>true</code>です。シミュレーション時間については<a href="http://www.ros.org/wiki/roscpp/Overview/Time">ROS C++ Time</a>をご覧ください。</p>

<h3>値をクリックする</h3>

<p>パラメータに何が設定されているか見るためには、以下のコマンドを実行してください。:</p>

<pre><code class="bash">rosparam get /use_sim_time 
</code></pre>

<h2>Gazeboが購読するトピック</h2>

<p>Topics</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ~/setlinkstate </td>
<td style="text-align:center;">gazebomsgs/LinkState </td>
<td style="text-align:center;"> リンクの姿勢(<code>pose/twist</code>)を設定します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/setmodelstate </td>
<td style="text-align:center;">gazebomsgs/ModelState </td>
<td style="text-align:center;"> モデルの姿勢(<code>pose/twist</code>)を設定します。</td>
</tr>
</tbody>
</table>


<h3>トピックを通じたシミュレーションにおけるモデルのPoseとTwist</h3>

<p><a href="http://www.ros.org/wiki/Topics">Topics</a>は<code>pose</code>の設定動作が完了するのを待つことなく、迅速にモデルの<code>pose</code>と<code>twist</code>を設定するのに使うことができます。そのようにするために、求められる<a href="http://www.ros.org/doc/api/gazebo/html/msg/ModelState.html">model state message</a>を<code>/gazebo/setmodelstate</code>トピックにpublishします。例えば、<code>topics</code>を通じて<code>pose</code>の設定をテストするために、オンラインデータベースからモデルをスポーンさせてコーラの缶をシミュレーションに追加します。:</p>

<pre><code class="bash">rosrun gazebo_ros spawn_model -database coke_can -gazebo -model coke_can -y 1
</code></pre>

<p>そして<code>/gazebo/setmodelstate</code>トピックにpublishすることで、コーラの缶の姿勢を設定します。:</p>

<pre><code class="bash">rostopic pub -r 20 /gazebo/set_model_state gazebo_msgs/ModelState '{model_name: coke_can, pose: { position: { x: 1, y: 0, z: 2 }, orientation: {x: 0, y: 0.491983115673, z: 0, w: 0.870604813099 } }, twist: { linear: { x: 0, y: 0, z: 0 }, angular: { x: 0, y: 0, z: 0}  }, reference_frame: world }'
</code></pre>

<p>すると以下のように、蹴ってくれと言わんばかりに(まあ、今から蹴るんですが)RRBotの前にコーラの缶が浮いているのを確認できるはずです。<br/>
ただし、以下のように、RRBotを追加するため、これまでに説明したroslaunchを使っています。:</p>

<pre><code class="bash">roslaunch rrbot_gazebo rrbot_world.launch
</code></pre>

<p><img src="/images/2015-03-02-gazebo-ros-communication/rrbot-test-1.png" alt="rrbot-test-1" /></p>

<h2>Gazeboがpuvlishするトピック</h2>

<p>Topics</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> /clock </td>
<td style="text-align:center;">rosgraphmsgs/Clock </td>
<td style="text-align:center;"> シミュレーション時間を<code>/usertime</code>パラメータと共にpublishします。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/linkstates </td>
<td style="text-align:center;">gazebomsgs/LinkStates </td>
<td style="text-align:center;"> シミュレーション中のすべてのリンクの状態をpublishします。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/modelstates </td>
<td style="text-align:center;">gazebo_msgs/ModelStates </td>
<td style="text-align:center;"> シミュレーション中のすべてのモデルの状態をpublishします。</td>
</tr>
</tbody>
</table>


<h3>Topicを使ってモデルとリンクの姿勢を訂正する</h3>

<p>Gazeboはworld座標系に関するシミュレーション中の物体のposeとtwistの情報を含む、<code>/gazebo/linkstates</code>と<code>/gazebo/modelstates</code>トピックをpublishしています。これらの挙動は、以下のコマンドを実行することで確認できます。</p>

<pre><code class="bash">rostopic echo -n 1 /gazebo/model_states
</code></pre>

<p>もしくは</p>

<pre><code class="bash">rostopic echo -n 1 /gazebo/link_states
</code></pre>

<p>繰り返すには、<code>link</code>が慣性、外観、衝突プロパティの定義された剛体として定義される必要があります。一方、<code>model</code>はリンクとジョイントの衝突要素として定義されます。<code>model</code>の状態は標準的な<code>link</code>の状態であります。URDFが木構造で与えられており、モデルのカノニカルリンクは自身のルートリンクによって定義されます。</p>

<h2>サービス : シミュレーション中のモデルの削除と作成</h2>

<p>以下のサービスでは、シミュレーション中のモデルを削除したり作成したりできます。:</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ~/spawnurdfmodel </td>
<td style="text-align:center;">gazebomsgs/SpawnModel </td>
<td style="text-align:center;"> Universal Robotic Description Format (URDF)をスポーンするために、このサービスを使います。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/spawnsdfmodel </td>
<td style="text-align:center;">gazebomsgs/SpawnModel </td>
<td style="text-align:center;"> Gazeboに記述されるSimulmulation Description Format (SDF)モデルをスポーンするために、このサービスを使います。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/deletemodel </td>
<td style="text-align:center;">gazebomsgs/DeleteModel </td>
<td style="text-align:center;"> シミュレーションからモデルを削除することができます。</td>
</tr>
</tbody>
</table>


<h3>モデルをスポーンする</h3>

<p><code>spawnmodel</code>と呼ばれるスクリプトはモデルの<code>gazeboros</code>によって呼び出されるスポーンサービスをコールするために提供されています。モデルをサービスコールを使ってスポーンするための最も実践的な方法は<code>roslaunch</code>ファイルを使うことです。詳細は、<a href="http://cir-kit.github.io/blog/2015/02/15/gazebo-using-roslaunch/">roslaunchを使う</a>というチュートリアルに書いてあります。URDFやSDFをGazeboに追加するために<code>spawn_model</code>を使う方法はたくさんあります。以下はそのうちのいくつかの例です。:<br/>
URDFをファイルからスポーンする - まず最初に<code>.Xacro</code>ファイルを<code>.xml</code>ファイルに変換し、スポーンします。:</p>

<pre><code class="bash">rosrun xacro xacro `rospack find rrbot_description`/urdf/rrbot.xacro &gt;&gt; `rospack find rrbot_description`/urdf/rrbot.xml
rosrun gazebo_ros spawn_model -file `rospack find rrbot_description`/urdf/rrbot.xml -urdf -y 1 -model rrbot1 -robot_namespace rrbot1
</code></pre>

<p><code>roslaunch</code>と<code>xacro</code>を使ったパラメータサーバーからのURDF: <a href="http://cir-kit.github.io/blog/2015/02/15/gazebo-using-roslaunch/">roslaunchを使う</a>をご覧ください。<br/>
ローカルモデルデータベースからのSDF:</p>

<pre><code class="bash">rosrun gazebo_ros spawn_model -file `echo $GAZEBO_MODEL_PATH`/coke_can/model.sdf -sdf -model coke_can1 -y 0.2 -x -0.3
</code></pre>

<p>オンラインモデルデータベースからのSDF:</p>

<pre><code class="bash">rosrun gazebo_ros spawn_model -database coke_can -sdf -model coke_can3 -y 2.2 -x -0.3
</code></pre>

<p>名前空間、<code>trimesh</code>プロパティ、ジョイントポジション、RPYオリエンテーションを含む<code>spawn_model</code>のための利用可能な引数をすべて見るには、以下を実行してください。:</p>

<pre><code class="bash">rosrun gazebo_ros spawn_model -h
</code></pre>

<h3>モデルを削除する</h3>

<p>すでにGazeboの中にあるモデルの削除は、物体に与えたモデルの名前を覚えている限りは簡単です。もし、RRBotを前のセクションで記述したように、<code>rrbot1</code>と名付けているなら、以下のコマンドでそれを削除できます。:</p>

<pre><code class="bash">rosservice call gazebo/delete_model '{model_name: rrbot1}'
</code></pre>

<h2>サービス : 状態とプロパティのセッティング</h2>

<p>以下のサービスでは、シミュレーション中の物体やシミュレーションについての状態やプロパティの情報を設定することができます。:</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ~/setlinkproperties </td>
<td style="text-align:center;">gazebomsgs/SetLinkProperties</td>
<td></td>
</tr>
<tr>
<td style="text-align:center;"> ~/setphysicsproperties </td>
<td style="text-align:center;">gazebomsgs/SetPhysicsProperties</td>
<td></td>
</tr>
<tr>
<td style="text-align:center;"> ~/setmodelstate </td>
<td style="text-align:center;">gazebomsgs/SetModelState</td>
<td></td>
</tr>
<tr>
<td style="text-align:center;"> ~/setmodelconfiguration </td>
<td style="text-align:center;">gazebomsgs/SetModelConfiguration </td>
<td style="text-align:center;"> モデルのジョイントポジションをダイナミクスなしで設定できるようになります。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/setjointproperties </td>
<td style="text-align:center;">gazebomsgs/SetJointProperties</td>
<td></td>
</tr>
<tr>
<td style="text-align:center;"> ~/setlinkstate </td>
<td style="text-align:center;">gazebomsgs/SetLinkState</td>
<td></td>
</tr>
<tr>
<td style="text-align:center;"> ~/setlinkstate </td>
<td style="text-align:center;">gazebomsgs/LinkState</td>
<td></td>
</tr>
<tr>
<td style="text-align:center;"> ~/setmodelstate </td>
<td style="text-align:center;">gazebomsgs/ModelState</td>
<td></td>
</tr>
</tbody>
</table>


<h3>モデルの姿勢を設定する例</h3>

<p><code>/gazebo/setmodelstate</code>サービスを使い、RRBotでコーラの缶を蹴ってみましょう !<br/>
もし、まだシミュレーションにコーラの缶を追加していないのなら、以下のコマンドを実行してください。:</p>

<pre><code class="bash">rosrun gazebo_ros spawn_model -database coke_can -gazebo -model coke_can -y 1
</code></pre>

<p>これは、Gazeboもしくはオンラインモデルデータベース(インターネット接続が必要です)を通じて利用可能になるようパッケージされていなければなりません。尚、コーラの缶がどこにあっても問題はありません。<br/>
続いて、コーラの缶をRRBotのポジションに動かすためのサービスリクエストをコールしましょう。:</p>

<pre><code class="bash">rosservice call /gazebo/set_model_state '{model_state: { model_name: coke_can, pose: { position: { x: 0.3, y: 0.2 ,z: 0 }, orientation: {x: 0, y: 0.491983115673, z: 0, w: 0.870604813099 } }, twist: { linear: {x: 0.0 , y: 0 ,z: 0 } , angular: { x: 0.0 , y: 0 , z: 0.0 } } , reference_frame: world } }'
</code></pre>

<p>すると、以下のようになるはずです。</p>

<p><img src="/images/2015-03-02-gazebo-ros-communication/rrbot-test-2.png" alt="rrobt-test-2" /></p>

<p>続いて、RRBotを以下のコマンドを使って動かしてみましょう。</p>

<pre><code class="bash">rosservice call /gazebo/set_model_state '{model_state: { model_name: rrbot, pose: { position: { x: 1, y: 1 ,z: 10 }, orientation: {x: 0, y: 0.491983115673, z: 0, w: 0.870604813099 } }, twist: { linear: {x: 0.0 , y: 0 ,z: 0 } , angular: { x: 0.0 , y: 0 , z: 0.0 } } , reference_frame: world } }'
</code></pre>

<p>うまく行けば、コーラの缶がどこかに飛んでゆくでしょう。(゜Д゜)ノ&#8221;<br/>
うまいう行かなかったら、やり直してみましょう。これはチュートリアルなんですから。<br/>
ちなみに、以下の動画みたいになります。以下の動画では、缶が転がってます。私も何回かやりましたが、缶が気持ちよく飛んでゆくこともありましたw</p>

<p>&lt; div class=&ldquo;youtube-container&rdquo;></p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/A8tGFOlgRdg" frameborder="0" allowfullscreen></iframe>


<p></div></p>

<h2>サービス : 状態とプロパティの取得</h2>

<p>以下のサービスでは、シミュレーション中の物体やシミュレーションについての状態やプロパティの情報を取得することができます。:</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ~/getmodelproperties </td>
<td style="text-align:center;">gazebomsgs/GetModelProperties</td>
<td style="text-align:center;"> シミュレーション中のモデルのプロパティを返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/getmodelstate </td>
<td style="text-align:center;">gazebomsgs/GetModelState </td>
<td style="text-align:center;"> シミュレーション中のモデルの状態を返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/getworldproperties </td>
<td style="text-align:center;">gazebomsgs/GetWorldProperties </td>
<td style="text-align:center;"> シミュレーションworldのプロパティを返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/getjointproperties </td>
<td style="text-align:center;">gazebomsgs/GetJointProperties </td>
<td style="text-align:center;"> シミュレーション中のジョイントのプロパティを返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/getlinkproperties </td>
<td style="text-align:center;">gazebomsgs/GetLinkProperties </td>
<td style="text-align:center;"> シミュレーション中のリンクのプロパティを返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/getlinkstate </td>
<td style="text-align:center;">gazebomsgs/GetLinkState </td>
<td style="text-align:center;"> シミュレーション中のリンクの状態を返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/getphysicsproperties </td>
<td style="text-align:center;">gazebomsgs/GetPhysicsProperties </td>
<td style="text-align:center;"> シミュレーション中で使用される物理エンジンのプロパティを返します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/linkstates </td>
<td style="text-align:center;">gazebomsgs/LinkStates </td>
<td style="text-align:center;"> world座標の完全なリンクの状態をpublishします。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/modelstates </td>
<td style="text-align:center;">gazebo_msgs/ModelStates </td>
<td style="text-align:center;"> world座標の完全なモデルの状態をpublishします。</td>
</tr>
</tbody>
</table>


<h2>注意</h2>

<p>Gazebo中のリンクの名前は<code>modelname::body_name</code>の名前表記にスコープされます。</p>

<h3>モデルの状態を取得する例</h3>

<p>さて、すでにコーラの缶を<strong>蹴った</strong>ことでしょう。今度は、それがどのくらい飛んだのか知りたいですね。これまでの例を使い(同じシミュレーションを実行して)、以下のサービスコールを使ってコーラの缶の<code>pose</code>と<code>twist</code>を取得しましょう。:</p>

<pre><code class="bash">rosservice call gazebo/get_model_state '{model_name: coke_can}'
</code></pre>

<p>この結果は、ロボットの蹴った具合によって変わりますが、以下のような感じになるはずです。:</p>

<pre><code class="bash">pose: 
  position: 
    x: -33.4741996929
    y: 1.72965811349
    z: 0.0715116701823
  orientation: 
    x: 0.52144600413
    y: 0.478438115917
    z: -0.471063379854
    w: -0.526583636448
twist: 
  linear: 
    x: 5.74579911953e-07
    y: 0.000217124920081
    z: 9.67915822705e-06
  angular: 
    x: -0.0029562892652
    y: 7.77750570372e-06
    z: 4.16767016512e-05
success: True
</code></pre>

<p>私のロボットは 33 [m]飛ばしました。あなたのはどうでしたか ?</p>

<h3>シミュレーションworldとオブジェクトプロパティを取得する</h3>

<p>以下のコマンドで、worldの中のモデルのリスト(<code>ground_plane</code>, <code>coke cane</code>, <code>rrbot</code>)を取得することができます。:</p>

<pre><code class="bash">rosservice call gazebo/get_world_properties
</code></pre>

<p>すると、以下のような結果が得られるはずです。</p>

<pre><code class="bash">sim_time: 59.62
model_names: ['ground_plane', 'rrbot', 'coke_can']
rendering_enabled: True
success: True
status_message: GetWorldProperties: got properties
</code></pre>

<p>また、以下のコマンドで特定のモデルの詳細を取得できます。</p>

<pre><code class="bash">rosservice call gazebo/get_model_properties '{model_name: rrbot}'
</code></pre>

<p>すると、以下の様な結果が得られるはずです。</p>

<pre><code class="bash">parent_model_name: ''
canonical_body_name: ''
body_names: ['link1', 'link2', 'link3']
geom_names: ['link1_collision', 'link2_collision', 'link3_collision', 'link3_collision_camera_link', 'link3_collision_hokuyo_link']
joint_names: ['fixed', 'joint1', 'joint2']
child_model_names: []
is_static: False
success: True
status_message: GetModelProperties: got properties
</code></pre>

<h2>サービス : 力のコントロール</h2>

<p>以下のサービスでは、シミュレーション中のボディやジョイントへの力とねじりを適用することができます。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ~/applybodywrench </td>
<td style="text-align:center;">gazebomsgs/ApplyBodyWrench </td>
<td style="text-align:center;"> シミュレーション中のボディにねじりを適用します。同じボディに適用されるすべてのアクティブなねじりは累積します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/applyjointeffort </td>
<td style="text-align:center;">gazebomsgs/ApplyJointEffort </td>
<td style="text-align:center;"> シミュレーション中のジョイントへの力を適用します。同じジョイントに適用されるすべてのアクティブな力は累積します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/clearjointforces </td>
<td style="text-align:center;">gazebomsgs/ClearJointForces </td>
<td style="text-align:center;"> ジョイントへ適用されている力をクリアします。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/clearbodywrenches </td>
<td style="text-align:center;">gazebomsgs/ClearBodyWrenches </td>
<td style="text-align:center;"> ボディへ適用されているねじりをクリアします。</td>
</tr>
</tbody>
</table>


<h3>ねじりをリンクに適用する</h3>

<p>Gazeboのボディへのねじりの適用を説明するために、重力をなくして物体をスポーンさせてみましょう。すでにコーラの缶が追加されていることを確認してください。:</p>

<pre><code class="bash">rosrun gazebo_ros spawn_model -database coke_can -gazebo -model coke_can -y 1
</code></pre>

<p>続いて、<code>/gazebo/setphysicsproperties</code>サービスコールを送り、すべての軸の重力をなくしましょう。:</p>

<p>Then to turn off gravity send a service call to /gazebo/setphysicsproperties with no gravity in any of the axis:</p>

<pre><code class="bash">rosservice call /gazebo/set_physics_properties "
time_step: 0.001
max_update_rate: 1000.0
gravity: 
  x: 0.0
  y: 0.0
  z: 0.0
ode_config: 
  auto_disable_bodies: False
  sor_pgs_precon_iters: 0
  sor_pgs_iters: 50
  sor_pgs_w: 1.3
  sor_pgs_rms_error_tol: 0.0
  contact_surface_layer: 0.001
  contact_max_correcting_vel: 100.0
  cfm: 0.0
  erp: 0.2
  max_contacts: 20"
</code></pre>

<p><code>/gazebo/applybodywerch</code>サービスを呼び、コーラの缶の原点に１秒間、0.01 [Nm]のトルクを適用しましょう。すると、コーラの缶が、X軸に対して正の方向にスピンするのが確認できるはずです。:</p>

<pre><code class="bash">rosservice call /gazebo/apply_body_wrench '{body_name: "coke_can::link" , wrench: { torque: { x: 0.01, y: 0 , z: 0 } }, start_time: 10000000000, duration: 1000000000 }'
</code></pre>

<p>今度は、コーラの缶の原点に1秒間、-0.01 [Nm]のトルクを適用し、缶の回転を止めましょう。:</p>

<pre><code class="bash">rosservice call /gazebo/apply_body_wrench '{body_name: "coke_can::link" , wrench: { torque: { x: -0.01, y: 0 , z: 0 } }, start_time: 10000000000, duration: 1000000000 }'
</code></pre>

<p>通常、負のトルクは、曖昧な定義であることが多いです。すべてのアクティブなねじりをボディに適用するには、以下のようなコマンドを実行してください。:</p>

<pre><code class="bash">rosservice call /gazebo/clear_body_wrenches '{body_name: "coke_can::link"}'
</code></pre>

<h3>シミュレーション中のジョイントに力を適用する</h3>

<p>ジョイントにトルクを適用するために、<code>/gazebo/applyjointeffort</code>をコールしてください。:</p>

<pre><code class="bash">rosservice call /gazebo/apply_joint_effort "joint_name: 'joint2'
effort: 10.0
start_time:
  secs: 0
  nsecs: 0
duration:
  secs: 10
  nsecs: 0"
</code></pre>

<p>するとリンクが回り始めるはずです。<br/>
特定のジョイントの力をクリアするためには、以下のコマンドをコールしてください。:</p>

<pre><code class="bash">rosservice call /gazebo/clear_joint_forces '{joint_name: joint2}'
</code></pre>

<h2>サービス : シミュレーションコントロール</h2>

<p>以下のサービスでは、シミュレーション中の物理エンジンを一時停止したり解除したリアできます。:</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 名前 </th>
<th style="text-align:center;"> 型 </th>
<th style="text-align:center;"> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ~/pausephysics </td>
<td style="text-align:center;">stdsrvs/Empty </td>
<td style="text-align:center;"> 物理エンジンのアップデートを一時停止します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/unpausephysics </td>
<td style="text-align:center;">stdsrvs/Empty </td>
<td style="text-align:center;"> 物理エンジンのアップデートを再開します。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/resetsimulation </td>
<td style="text-align:center;">stdsrvs/Empty </td>
<td style="text-align:center;"> モデルのポーズをリセットします。</td>
</tr>
<tr>
<td style="text-align:center;"> ~/resetworld </td>
<td style="text-align:center;">stdsrvs/Empty </td>
<td style="text-align:center;"> 時間を含むすべてのシミュレーションをリセットします。</td>
</tr>
</tbody>
</table>


<h3>物理エンジンのアップデートを一時停止する</h3>

<p>飛んでゆくコーラの缶のナイスなスクリーンショットを撮りたいとしましょう。いや、そうだと言ってください。そんな時には、以下のコマンドをコールすることで、物理エンジンを一時停止することができます。:</p>

<pre><code class="bash">rosservice call gazebo/pause_physics
</code></pre>

<p>シミュレーションが一時停止するとき、シミュレーション時間が停止し、物体も静的になります。しかし、Gazeboの内部アップデートループ(カスタムのダイナミクスプラグインアップデートなど)は依然として動いており、シミュレーション時間は変わっていません。これは、シミュレーションタイムをアップデートしないことで抑制されているのです。シミュレーションを再開するために、以下のコマンドをコールして物理エンジンを再開してください。:</p>

<pre><code class="bash">rosservice call gazebo/unpause_physics
</code></pre>

<h2>次のステップ</h2>

<p>Gazeboのための独自のROSプラグインの作り方について学んでください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CIR-KITメンバーが必ずすべきこと]]></title>
    <link href="http://cir-kit.github.io/blog/2015/02/25/we-have-get-to-work-when-install-ubuntu/"/>
    <updated>2015-02-25T20:31:54+09:00</updated>
    <id>http://cir-kit.github.io/blog/2015/02/25/we-have-get-to-work-when-install-ubuntu</id>
    <content type="html"><![CDATA[<h1>CIR-KIT開発環境への道</h1>

<h2>概要</h2>

<p>この記事はOSインストールからのCIR-KITでの環境を整えるまでの手順を残すためのものです。
なお、各手順の目的を達成できれば別の手段を使用しても構いません。</p>

<h2>重要度</h2>

<p>LOW</p>

<!--more-->


<h2>目的と手段の一覧</h2>

<p>推奨時系列順にすべきことをリストアップしました。強調部分は手段が確定しています。</p>

<table>
<thead>
<tr>
<th style="text-align:left;">目的</th>
<th style="text-align:left;">手段</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">日本語入力の獲得</td>
<td style="text-align:left;">mozcを導入</td>
</tr>
<tr>
<td style="text-align:left;">gitの獲得</td>
<td style="text-align:left;"><strong>gitの導入</strong></td>
</tr>
<tr>
<td style="text-align:left;">githubへの参加</td>
<td style="text-align:left;"><strong>グループ(CIR-KIT)に招待を貰う</strong></td>
</tr>
<tr>
<td style="text-align:left;">blog更新手段の獲得</td>
<td style="text-align:left;"><strong>CIR-KIT.OctopressのWiki参照</strong></td>
</tr>
<tr>
<td style="text-align:left;">ROSの獲得</td>
<td style="text-align:left;"><strong>ROSの導入</strong></td>
</tr>
<tr>
<td style="text-align:left;">Gazeboの獲得</td>
<td style="text-align:left;"><strong>Gazeboの導入</strong></td>
</tr>
</tbody>
</table>


<h2>手段達成方法</h2>

<p>各手段の達成方法を記す。</p>

<hr />

<h3>日本語入力の獲得(Mozcの導入)</h3>

<p>デフォルトの設定では日本語入力ができなかったり、押したキーと別の文字が出たり(キー配列が英仕様として認識される)します。
ここでは、Mozc(もずく)によって日本語入力できるようにし、設定をしてキー配列を日仕様にします。</p>

<h4>この処置の結果</h4>

<p>日仕様のキー配列に対応し、半角全角キーで日本語と半角英数字の切り替えを行える。</p>

<h4>手順</h4>

<ol>
<li>Mozcをインストールする

<ul>
<li>コンソールで<code>sudo apt-get install ibus-mozc</code>を実行する
<code>bash
sudo apt-get install ibus-mozc
</code></li>
</ul>
</li>
<li>PCを再起動する</li>
<li>テキスト入力設定を変更する

<ul>
<li>右上のWi-Fi設定の右隣にあるアイコンをクリックして、テキスト入力設定を選択</li>
<li>使用する日本語ソースを<strong>日本語</strong>,<strong>日本語(Mozc)</strong>の2つにする</li>
<li>次のソースへ切り替えのキーを半角全角キーにする</li>
</ul>
</li>
</ol>


<h4>確認方法</h4>

<p>どこでもいいのでテキストを入力する。半角全角キーで日本語入力と半角英数が切り替わるか確認する。</p>

<hr />

<h3>gitの獲得</h3>

<p>CIR-KITでの開発はgitによって管理される。gitはバージョン管理システムであり、CIR-KITメンバーはこれをインストールしなければならない。</p>

<h4>この処置の結果</h4>

<p>gitの使用が可能になる。</p>

<h4>手順</h4>

<ol>
<li>gitをインストールする

<ul>
<li>コンソールで<code>sudo apt-get install git</code>を実行する
<code>bash
sudo apt-get install git
</code></li>
</ul>
</li>
</ol>


<h4>確認方法</h4>

<p>コンソールで<code>git --version</code>を実行しversionを表す数字などが表示されればよい。
<code>bash
git --version
</code></p>

<hr />

<h3>blog更新手段の獲得</h3>

<p>CIR-KITでは発見、紹介、残しておきたいことをブログにしている。これにより、自らの学んだ技術が残せるだけでなく、後世の者まで知識を利用できる。CIR-KITメンバーはこれを有効に利用するべし。</p>

<h4>この処置の結果</h4>

<p>CIR-KITのブログが更新できるようになる。</p>

<h4>手順</h4>

<p><a href="https://github.com/CIR-KIT/CIR-KIT.Octopress/wiki/Home">専用のwiki</a>を読むこと</p>

<h4>確認方法</h4>

<p>上記のWikiを参考にしてください。</p>

<hr />

<h3>ROSの獲得</h3>

<p>ROSはCIR-KITのロボット開発に使用されているものである。2015年現在これがないとCIE-KITのロボット開発ができない。</p>

<h4>この処置の結果</h4>

<p>ROSの環境が整い、ROSによるロボット開発が可能になる。</p>

<h4>手順</h4>

<p><a href="http://wiki.ros.org/ja">公式Wiki</a>を読んでください。</p>

<h4>確認方法</h4>

<p><a href="http://wiki.ros.org/ja">公式Wiki</a>を読んでください。</p>

<hr />

<h3>Gazeboの獲得</h3>

<p>Gazeboは3Dロボットシュミレータである。ROSとの連携が豊富という特徴を持つ。これによりロボットが完成する前からソフトの開発が可能になる。また、ハードとソフトの問題の切り分けも容易になる。</p>

<h4>この処置の結果</h4>

<p>Gazeboの環境が整う。</p>

<h4>手順</h4>

<ol>
<li>Gazeboをインストールする

<ul>
<li>コンソールで以下のコードを実行する
<code>bash
wget -O /tmp/gazebo4_install.sh http://osrf-distributions.s3.amazonaws.com/gazebo/gazebo4_install.sh; sudo sh /tmp/gazebo4_install.sh
</code></li>
</ul>
</li>
</ol>


<h4>確認方法</h4>

<p>コンソールで<code>gazebo</code>を実行して、Gazeboが立ち上がればよい。
<code>bash
gazebo
</code></p>
]]></content>
  </entry>
  
</feed>
